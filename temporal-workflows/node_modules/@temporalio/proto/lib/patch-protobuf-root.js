"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.patchProtobufRoot = patchProtobufRoot;
const ROOT_PROPS = [
    'options',
    'parsedOptions',
    'name',
    'parent',
    'resolved',
    'comment',
    'filename',
    'nested',
    '_nestedArray',
];
/**
 * Create a version of `root` with non-nested namespaces to match the generated types.
 * For more information, see:
 * https://github.com/temporalio/sdk-typescript/blob/main/docs/protobuf-libraries.md#current-solution
 * @param root Generated by `pbjs -t json-module -w commonjs -o json-module.js *.proto`
 * @returns A new patched `root`
 */
function patchProtobufRoot(root) {
    return _patchProtobufRoot(root);
}
function _patchProtobufRoot(root, name) {
    const newRoot = new root.constructor(isNamespace(root) ? name : {});
    for (const key in root) {
        newRoot[key] = root[key];
    }
    if (isRecord(root.nested)) {
        for (const typeOrNamespace in root.nested) {
            const value = root.nested[typeOrNamespace];
            if (ROOT_PROPS.includes(typeOrNamespace)) {
                console.log(`patchProtobufRoot warning: overriding property '${typeOrNamespace}' that is used by protobufjs with the '${typeOrNamespace}' protobuf ${isNamespace(value) ? 'namespace' : 'type'}. This may result in protobufjs not working property.`);
            }
            if (isNamespace(value)) {
                newRoot[typeOrNamespace] = _patchProtobufRoot(value, typeOrNamespace);
            }
            else if (isType(value)) {
                newRoot[typeOrNamespace] = value;
            }
        }
    }
    return newRoot;
}
function isType(value) {
    // constructor.name may get mangled by minifiers; thanksfuly protobufjs also sets a constructor.className property
    return isRecord(value) && value.constructor.className === 'Type';
}
function isNamespace(value) {
    // constructor.name may get mangled by minifiers; thanksfuly protobufjs also sets a constructor.className property
    return isRecord(value) && value.constructor.className === 'Namespace';
}
// Duplicate from type-helpers instead of importing in order to avoid circular dependency
function isRecord(value) {
    return typeof value === 'object' && value !== null;
}
//# sourceMappingURL=patch-protobuf-root.js.map