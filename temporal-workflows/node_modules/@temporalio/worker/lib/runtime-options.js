"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.compileOptions = compileOptions;
exports.makeTelemetryFilterString = makeTelemetryFilterString;
const time_1 = require("@temporalio/common/lib/time");
const logger_1 = require("./logger");
const runtime_logger_1 = require("./runtime-logger");
function compileOptions(options) {
    const { metrics, noTemporalPrefixForMetrics } = options.telemetryOptions ?? {}; // eslint-disable-line deprecation/deprecation
    const [logger, logExporter] = compileLoggerOptions(options);
    const heartbeatMillis = (0, time_1.msToNumber)(options.workerHeartbeatInterval ?? '60s');
    return {
        logger,
        shutdownSignals: options.shutdownSignals ?? ['SIGINT', 'SIGTERM', 'SIGQUIT', 'SIGUSR2'],
        runtimeOptions: {
            logExporter,
            telemetry: {
                metricPrefix: metrics?.metricPrefix ?? (noTemporalPrefixForMetrics ? '' : 'temporal_'),
                attachServiceName: metrics?.attachServiceName ?? true,
            },
            metricsExporter: metrics && isPrometheusMetricsExporter(metrics)
                ? {
                    type: 'prometheus',
                    socketAddr: metrics.prometheus.bindAddress,
                    countersTotalSuffix: metrics.prometheus.countersTotalSuffix ?? false,
                    unitSuffix: metrics.prometheus.unitSuffix ?? false,
                    useSecondsForDurations: metrics.prometheus.useSecondsForDurations ?? false,
                    histogramBucketOverrides: metrics.prometheus.histogramBucketOverrides ?? {},
                    globalTags: metrics.globalTags ?? {},
                }
                : metrics && isOtelCollectorExporter(metrics)
                    ? {
                        type: 'otel',
                        url: metrics.otel.url,
                        protocol: metrics.otel.http ? 'http' : 'grpc',
                        headers: metrics.otel.headers ?? {},
                        metricPeriodicity: (0, time_1.msToNumber)(metrics.otel.metricsExportInterval ?? '1s'),
                        useSecondsForDurations: metrics.otel.useSecondsForDurations ?? false,
                        metricTemporality: metrics.otel.temporality ?? metrics.temporality ?? 'cumulative', // eslint-disable-line deprecation/deprecation
                        histogramBucketOverrides: metrics.otel.histogramBucketOverrides ?? {},
                        globalTags: metrics.globalTags ?? {},
                    }
                    : null,
            workerHeartbeatIntervalMillis: heartbeatMillis === 0 ? null : heartbeatMillis,
        },
    };
}
function compileLoggerOptions(options) {
    const { logging, tracingFilter } = options.telemetryOptions ?? {}; // eslint-disable-line deprecation/deprecation
    const logger = options.logger ?? new logger_1.DefaultLogger('INFO');
    // Unfortunately, "filter" has changed place and semantics a few times in the past, and we want to
    // do our best not to break existing users, so this gets a bit more complex than it should be.
    const defaultFilter = tracingFilter ?? makeTelemetryFilterString({ core: 'WARN', other: 'ERROR' });
    let loggingFilter = undefined;
    if (logging?.filter) {
        if (typeof logging.filter === 'string') {
            loggingFilter = logging.filter;
        }
        else if (typeof logging.filter === 'object') {
            loggingFilter = makeTelemetryFilterString(logging.filter);
        }
        else {
            throw new TypeError('Invalid logging filter');
        }
    }
    // eslint-disable-next-line deprecation/deprecation
    const forwardLevel = logging?.forward?.level;
    const forwardLevelFilter = forwardLevel &&
        makeTelemetryFilterString({
            core: forwardLevel,
            other: forwardLevel,
        });
    if (logging && isForwardingLogger(logging)) {
        const collector = new runtime_logger_1.NativeLogCollector(logger);
        return [
            collector.logger,
            {
                type: 'forward',
                filter: loggingFilter ?? forwardLevelFilter ?? defaultFilter,
                receiver: collector.receive,
            },
        ];
    }
    else {
        return [
            logger,
            {
                type: 'console',
                filter: loggingFilter ?? defaultFilter,
            },
        ];
    }
}
/**
 * A helper to build a filter string for use in `RuntimeOptions.telemetryOptions.tracingFilter`.
 *
 * Note that one may instead simply pass a {@link CoreLogFilterOptions} object directly to
 * `RuntimeOptions.telemetryOptions.logging.filter`. This function may however still be useful
 * in some particular use cases and will therefore be kept around.
 */
function makeTelemetryFilterString(options) {
    const { core, other } = options;
    return `${other ?? 'ERROR'},temporalio_sdk_core=${core},temporalio_client=${core},temporalio_common=${core}`;
}
function isOtelCollectorExporter(metrics) {
    return 'otel' in metrics && typeof metrics.otel === 'object';
}
function isPrometheusMetricsExporter(metrics) {
    return 'prometheus' in metrics && typeof metrics.prometheus === 'object';
}
function isForwardingLogger(options) {
    return 'forward' in options && typeof options.forward === 'object';
}
//# sourceMappingURL=runtime-options.js.map